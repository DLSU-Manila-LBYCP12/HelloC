/*****************************************************/
/*
/*                 Linked List Demo
/*
/*****************************************************/

typedef char T[30];   // Item element type




/*=============================*/
/*       Linked List ADT 
/*=============================*/
typedef struct node *node_ptr;

struct node{
    T item;
    node_ptr next;
};

typedef node_ptr LIST;
typedef node_ptr position;
/*=============================*/




/*=============================*/
/*  Linked List Implementation 
/*=============================*/
/*******************************/
/*          OPERATIONS         */
/*******************************/

int isEmpty( LIST L ){
// postcondition: Determine if a list is empty
   return (L->next == NULL);
}


position find( LIST L, T x ){
// postcondition: Return element x is in the LIST (if it exists)
   position p = L->next;

   while ((p != NULL) && (p->item != x))
       p = p->next; 

   return p;
}


void delete( LIST L, T x ){
// postcondition: Delete element x
   position p, tmp;
   p = previous( x, L);

   if( p->next != NULL ){
        tmp = p->next;
        p->next = tmp -> next;
        free( tmp );
   }
}


position previous( LIST L, T x ){
// postcondition: Return the previous item of element x
   position p = L;

   while ( (p->next != NULL) && (p->next->item != x )
       p = p->next;
 
   return p;
}


void insert( LIST L, T x, position p ){
// postcondition: Insert an item in position p
   position tmp;

   tmp = (position) malloc( sizeof(struct node));

   if( tmp == NULL )
      fatal_error("Out of space");
   else {
       tmp->item = x;
       tmp->next = p->next;
       p->next = tmp
   }
}


void deleteAll( LIST L ){
   position p, tmp;

   p = L->next;
   L->next = NULL;

   while( p != NULL ){
       tmp = p->next;
       free(p);
       p = tmp;
   }
}





/*=============================*/
/*      Linked List Test 
/*=============================*/
int main(void){

        char c;       // command	
	int l;        // list length
	int position; // list position 
	int quit = 0; // sentinel	
	
        T newitem;
        LIST L;

        printf("\n-");

	while (quit == 0)
	{

         if ( (c = getchar()) != '\n') {            
          

	switch (c)
	{
	case 'e':		
                if(isEmpty(&L))
		   printf("\n\nList Empty\n");
                else
                   printf("\n\nList Not Empty\n");
	        break;

	case 'l':
		l = length(&list);
		if(length < 0)
			printf("\n\nCreate an empty ordered list first!\n");
		else
			printf("\n\nLength = %d\n", l);
	        break;

	case 'i':
		if(list.size < 0)
			printf("\n\nCreate an empty ordered list first!\n");
		else if(list.size == MAX_ITEMS)
		        printf("\n\nList is Full\n");		
		else
		{
		       printf(" ");
		       scanf("%d %s", &position, newitem.y);
		       insert(&list, position, newitem);
		}
	        break;

	case 'd':
		if (list.size == 0)
         		printf("\n\nList Empty!\n");
		else if (list.size < 0)
			printf("\n\nCreate an empty ordered list first!\n");
		else
		{
		        printf(" ");
		        scanf("%d", &position);
		        if (position > list.size)
			     printf("\n\nThere's no item in that position!\n");
			else
		            listDelete(&list, position);
		}
	        break;

	case 's':
         	display(&list);
	        break;

	case 'q':
		quit = 1;
	        break;

	default:
	     printf("\n\nYou have entered an incorrect Option!\n");
             break;
	} // END_SWITCH
 
        printf("\n-");
       }
     } // END_WHILE
   
	return EXIT_SUCCESS;
}
